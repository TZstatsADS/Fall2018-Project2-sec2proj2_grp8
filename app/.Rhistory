opt_lambda
fit <- cv_fit$glmnet.fit
y_predicted <- predict(fit, s = opt_lambda, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- cv_fit$glmnet.fit
y_predicted <- predict(fit, s = opt_lambda, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- cv_fit$glmnet.fit
y_predicted <- predict(fit, s = opt_lambda, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 93% of the variance in the data.
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
y_predicted <- predict(fit, s = opt_lambda, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
summary(fit)
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
library(MASS)
library(car)
ols<-lm(bwt~age+lwt+race+smoke+ptl+ht+ui+ftv,data = birthwt)
summary(ols)
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(5, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
summary(ols)
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(10, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
summary(ols)
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(10, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- cv.glmnet(x,y,alpha = 0, lambda = opt_lambda)
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
lambdas <- 10^seq(10, -5, by = -.1)
cv_fit <- cv.glmnet(x, y, alpha = 0, lambda = lambdas)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
summary(ols)
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
cv_fit <- cv.glmnet(x, y, alpha = 0)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
fit$ beta
y_predicted <- predict(fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
summary(ols)
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
cv_fit <- cv.glmnet(x, y, alpha = 0)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
ridge_fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
ridge_fit$ beta
y_predicted <- predict(ridge_fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
summary(ols)
lasso <- cv.glmnet(x, y, alpha = 1)
plot(lasso)
opt_lasso<-cv_fit$lambda.min
opt_lasso
lasso_fit<-glmnet(x,y,alpha = 1, lambda = opt_lasso)
#coefficients of lasso predictors
lasso_fit$beta
lasso <- cv.glmnet(x, y, alpha = 1)
plot(lasso)
opt_lasso<-lasso$lambda.min
opt_lasso
lasso_fit<-glmnet(x,y,alpha = 1, lambda = opt_lasso)
#coefficients of lasso predictors
lasso_fit$beta
#stepwise model selectio
#Forward selection
full <- glm(bwt ~ age+lwt+race+smoke+ptl+ht+ui+ftv, data = birthwt)
null <- glm(bwt~1,data = dataall)
#stepwise model selectio
#Forward selection
full <- glm(bwt ~ age+lwt+race+smoke+ptl+ht+ui+ftv, data = birthwt)
null <- glm(bwt~1,data =birthwt)
forward <- stepAIC(null, direction="forward",scope=list(upper = full,lower = null),trace = F,data = birthwt)
forward
#backward selection
backward <- stepAIC(full, direction="backward",scope=list(upper = full,lower =null),trace = F,data= birthwt)
backward
#stepwise model selectio
#Forward selection
full <- glm(bwt ~ age+lwt+race+smoke+ptl+ht+ui+ftv, data = birthwt)
null <- glm(bwt~1,data =birthwt)
forward <- stepAIC(null, direction="forward",scope=list(upper = full,lower = null),trace = F,data = birthwt)
forward
#backward selection
backward <- stepAIC(full, direction="backward",scope=list(upper = full,lower =null),trace = F,data= birthwt)
backward
#Stepwise selection
stepAIC(full, direction="both")
birthwt$race
View(birthwt)
#vif
vif(ols)
mean(vif(ols))
#condition number
#using condition number = ratio of largest to smallest eigenvalues of correlation matrix. When it is exct collinearity, all eigenvalue = 0. when condition number > 30, multicollinearity.
eigenvalue = eigen(cor(birthwt[,2:9]))
condition_number = max(eigenvalue$values)/min(eigenvalue$values)
condition_number
library(glmnet)
y<-birthwt$bwt
x<-as.matrix(birthwt[,2:9])
cv_fit <- cv.glmnet(x, y, alpha = 0)
plot(cv_fit)
opt_lambda<-cv_fit$lambda.min
opt_lambda
ridge_fit <- glmnet(x,y,alpha = 0, lambda = opt_lambda)
#coefficients of lasso predictors
coef(ridge_fit)
y_predicted <- predict(ridge_fit, newx = x)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((y_predicted - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq
#The optimal model has accounted for 21% of the variance in the data.
summary(ols)
#lasso
lasso <- cv.glmnet(x, y, alpha = 1)
plot(lasso)
opt_lasso<-lasso$lambda.min
opt_lasso
lasso_fit<-glmnet(x,y,alpha = 1, lambda = opt_lasso)
#coefficients of lasso predictors
coef(lasso_fit)
#stepwise model selectio
#Forward selection
full <- glm(bwt ~ age+lwt+race+smoke+ptl+ht+ui+ftv, data = birthwt)
null <- glm(bwt~1,data =birthwt)
forward <- stepAIC(null, direction="forward",scope=list(upper = full,lower = null),trace = F,data = birthwt)
forward
# make prediction
forward_predict<-predict(forward, newx=x)
#backward selection
backward <- stepAIC(full, direction="backward",scope=list(upper = full,lower =null),trace = F,data= birthwt)
backward
#Stepwise selection
stepAIC(full, direction="both")
#stepwise model selectio
#Forward selection
full <- glm(bwt ~ age+lwt+race+smoke+ptl+ht+ui+ftv, data = birthwt)
null <- glm(bwt~1,data =birthwt)
forward <- stepAIC(null, direction="forward",scope=list(upper = full,lower = null),trace = F)
forward
# make prediction
forward_predict<-predict(forward, newx=x)
#mse for stepwise
mean((step.pred - y)^2)
#mse for stepwise
mean((stepwise_predict - y)^2)
#Stepwise selection
stepwise<-stepAIC(full, direction="both", trace=F)
stepwise
## make prediction
stepwise_predict <- predict(stepwise, newx=x)
#mse for stepwise
mean((stepwise_predict - y)^2)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((stepwise_predict - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq #0.2376879 : The optimal model has accounted for 24% of the variance in the data
#Stepwise selection
stepwise<-stepAIC(full, direction="both", trace=F)
stepwise
## make prediction
stepwise_predict <- predict(stepwise, newx=x)
# Stepwise selection method keeps lwt, race, smoke, ht, and ui.
#mse for stepwise
mean((stepwise_predict - y)^2)
# Sum of Squares Total and Error
sst <- sum((y - mean(y))^2)
sse <- sum((stepwise_predict - y)^2)
# R squared
rsq <- 1 - sse / sst
rsq #0.2213582 : The optimal model has accounted for 22% of the variance in the data
runApp('~/Desktop/Fall2018-Project2-sec2proj2_grp8/app')
runApp('~/Desktop/Fall2018-Project2-sec2proj2_grp8/app')
runApp('~/Desktop/Fall2018-Project2-sec2proj2_grp8/app')
runApp('~/Desktop/Fall2018-Project2-sec2proj2_grp8/app')
get_yelp_data <- function(latitude = 40.748817,
longitude = -73.985428,
categories = NULL,
radius = 5000,
price = NULL){
# Type inspection ---------------------------------------------------------
if(!is.double(latitude)) {
stop("latitude must be a decimal number")
} else {
lat <- latitude
}
if(!is.double(longitude)) {
stop("longitude must be a decimal number")
} else {
lng <- longitude
}
if(!is.numeric(radius)) {
stop("radius must be an integer number")
} else {
rad <- as.integer(radius)
}
if(!is.numeric(price)) {
stop("price must be of type integer")
} else {
p <- as.integer(price)
}
# Initialization ---------------------------------------------------------
yelp <- "https://api.yelp.com"
term <- "restaurants"
location <- "NYC"
typ <- categories
limit <- 50
# Add filter to search engine
url <- modify_url(yelp, path = c("v3", "businesses", "search"),
query = list(term = term,
location = location,
limit = limit,
longitude = lng,
latitude = lat,
price = p,
categories = typ,
radius = rad
)
)
# Send request to API and get results
res <- GET(url, add_headers('Authorization' = paste("bearer", "zLZesNlW8YSPyNP9poXD-_FDOhvNFACzrq-xAul5H3b6isbviX3o2EuCeifPRAsTvfz_c0lPzJUPNtzUIeowGHmhheCAxRMWz_lc5cqQAY-7X94pAvYkC3pXNjG2W3Yx")))
results <- content(res)
# Define a function to parse search results with only the columns needed -----
yelp_httr_parse <- function(x) {
# Set a list of wanted columns
parse_list <- list(id = x$id,
name = x$name,
rating = x$rating,
price = x$price,
review_count = x$review_count,
latitude = x$coordinates$latitude,
longitude = x$coordinates$longitude,
address1 = x$location$address1,
city = x$location$city,
state = x$location$state,
distance = x$distance
)
# Read results into the parse_list without useless columns
parse_list <- lapply(parse_list, FUN = function(x) ifelse(is.null(x), "", x))
# Change parse_list to data frame type
df <- data_frame(id=parse_list$id,
name=parse_list$name,
rating = parse_list$rating,
price = parse_list$price,
review_count = parse_list$review_count,
latitude=parse_list$latitude,
longitude = parse_list$longitude,
address1 = parse_list$address1,
city = parse_list$city,
state = parse_list$state,
distance= parse_list$distance)
df
}
# Call yelp_httr_parse() to get parse results and save in results_list -----------
results_list <- lapply(results$businesses, FUN = yelp_httr_parse)
payload <- do.call("rbind", results_list)
# Return
payload
}
setwd("./app")
setwd("/Users/Yiming/Desktop/Fall2018-Project2-sec2proj2_grp8/app")
setwd("..")
att_loc <- read.csv("./data/NYC_attractions.csv")
setwd("/Users/Yiming/Desktop/Fall2018-Project2-sec2proj2_grp8/app")
m = match(c('SL','CP'),att_loc$Code)
att_lng = att_loc$Latitude[m]
att_lat = att_loc$Longitude[m]
att_nm = att_loc$Attraction[m]
df_app = data.frame(att_nm, att_lng, att_lat)
shinyServer(function(input, output) {
# Map rendering -----------------------------------------------------------------------------
# Initialization
output$map <- renderLeaflet({
leaflet() %>%
setView(lng = -73.980, lat = 40.740, zoom =13) %>%
addProviderTiles("CartoDB.Positron")
})
#checkbox for price
output$value <- renderPrint({ input$checkGroup })
})
runApp()
runApp()
runApp()
